# AGENTS.md â€“ Ruby on Rails Development Guide

**Version**: 1.0 | **Compatibility**: Claude, Cursor, Copilot, Cline, Aider, all
AGENTS.md-compatible tools\
**Status**: Canonical guide for AI-assisted Rails development\
**Last Updated**: December 2025

---

## Table of Contents

1. [Compliance & Core Rules](#1-compliance--core-rules)
2. [Rails Development Standards](#2-rails-development-standards)
3. [Session Startup & Context](#3-session-startup--context)
4. [Project Structure & Memory Bank](#4-project-structure--memory-bank)
5. [State Machine](#5-state-machine)
6. [Task Contract](#6-task-contract)
7. [Quality & Testing](#7-quality--testing)
8. [Security & Code Review](#8-security--code-review)
9. [Troubleshooting](#9-troubleshooting)

---

**âš ï¸ Note on Gems**: Gem-specific patterns (Devise, Sidekiq, RSpec, etc.) are in
`gems.md`. Load that file when working with external gems to keep token usage
efficient.

---

## 1. Compliance & Core Rules

### Startup Compliance (Output Every Session)

```
COMPLIANCE CONFIRMED: Reuse over creation | Rails conventions respected

âš ï¸  GIGO PREVENTION - User Responsibilities:
ğŸ“‹ Clear task objectives | ğŸ”— Historical context | ğŸ¯ Success criteria
âš™ï¸  Architectural constraints | ğŸ–ï¸ You lead - clear input = excellent output

[Proceeding with Rails Guidelines + State Machine...]
```

### The Four Sacred Rules (Rails-Specific)

| Rule                                         | Requirement                                                            | Validation                                                                  |
| -------------------------------------------- | ---------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| âŒ **No new files without reuse analysis**   | Search codebase, check existing models/services, provide justification | "Analyzed `app/models/X`, `app/services/Y`. Cannot extend because [reason]" |
| âŒ **No rewrites when refactoring possible** | Prefer incremental improvements to existing services/models            | "Extending `User` model at line X rather than creating new model"           |
| âŒ **No ignoring Rails conventions**         | Follow CoC, MVC pattern, REST principles, Active Record patterns       | "Follows Rails conventions from `config/` and existing patterns"            |
| âŒ **No skipping tests**                     | TDD mandatoryâ€”red, green, refactor. Never commit without tests         | "Red: wrote failing test                                                    |

### Non-Negotiables

- **Approval Gates**: No commits without explicit user approval
- **Sandbox First**: All work in feature branches, never main/master
- **Citations**: Always `app/path/file.rb:42` (single line) or
  `app/path/file.rb:42-58` (range)
- **No Mock Data**: Never fake/simulated data in production; test fixtures are
  OK
- **No Secrets**: Never hardcode API keys, passwords, or credentials
- **TDD Mandatory**: Tests written before production code
- **Code Quality**: Must pass `rubocop` and `bundle exec rails test` and `ubs .`

---

## 2. Rails Development Standards

### Core Rails Principles

#### Convention over Configuration (CoC)

Following Rails conventions reduces code. Always ask: "Does Rails already
provide this?"

**Good**:

- Model: `app/models/user.rb` inheriting `ApplicationRecord`
- Controller: `app/controllers/users_controller.rb` with RESTful actions
- Migration: `db/migrate/TIMESTAMP_create_users.rb`

**Anti-Pattern**:

- Custom database layer bypassing Active Record
- Non-standard directory structures
- Controllers with multiple responsibilities

#### MVC Architecture

| Component      | Responsibility                                    | Anti-Pattern                     |
| -------------- | ------------------------------------------------- | -------------------------------- |
| **Model**      | Business logic, validation, associations, scopes  | Business logic in controller     |
| **Controller** | Request handling, coordination, response          | Complex logic, direct DB queries |
| **View**       | Presentation only, loops OK, complex logic NOT OK | Business logic in view           |

#### RESTful Design

Actions correspond to HTTP verbs:

```ruby
GET    /users           â†’ index (list all)
GET    /users/:id       â†’ show (single resource)
GET    /users/new       â†’ new (form)
POST   /users           â†’ create (persist new)
GET    /users/:id/edit  â†’ edit (form)
PATCH  /users/:id       â†’ update (persist changes)
DELETE /users/:id       â†’ destroy (delete)
```

**Rails generates routes automatically:**

```ruby
# config/routes.rb
resources :users  # Creates all 7 RESTful routes
```

#### Active Record Pattern

Models represent database tables:

```ruby
# app/models/user.rb
class User < ApplicationRecord
  has_many :posts
  validates :email, presence: true, uniqueness: true
  
  scope :active, -> { where(archived: false) }
  scope :recent, -> { order(created_at: :desc) }
end
```

**Never hand-write SQL**; use Active Record chainable methods.

#### Fat Models, Skinny Controllers

**Good**:

```ruby
# Model: Business logic
class User < ApplicationRecord
  def activate!
    update(activated_at: Time.current)
    send_welcome_email
  end
end

# Controller: Coordination only
def update
  @user = User.find(params[:id])
  if @user.update(user_params)
    redirect_to @user, notice: 'Updated'
  else
    render :edit
  end
end
```

**Anti-Pattern**:

```ruby
# Controller with business logic
def activate_user
  User.find(params[:id]).update(activated_at: Time.current)
  UserMailer.welcome_email(user).deliver_later
  # Should be in model!
end
```

#### Single Responsibility Principle (SRP)

Each class/module should have one reason to change.

**Good**:

```ruby
# app/services/user_registration.rb
class UserRegistration
  def initialize(user_params)
    @user_params = user_params
  end
  
  def call
    user = User.create!(@user_params)
    send_confirmation_email(user)
    user
  end
  
  private
  
  def send_confirmation_email(user)
    UserMailer.confirm_email(user).deliver_later
  end
end
```

**Anti-Pattern**:

```ruby
# User model doing too much
class User < ApplicationRecord
  def register_and_email_and_notify_admin_and_log
    # Too many responsibilities!
  end
end
```

#### Dependency Injection

Pass dependencies as parameters, don't hardcode them:

```ruby
# Good: Dependency injected
class UserService
  def initialize(email_service: UserMailer)
    @email_service = email_service
  end
  
  def create_and_notify(params)
    user = User.create(params)
    @email_service.notify(user)
  end
end

# Usage
service = UserService.new(email_service: TestMailer)

# Testing
it 'sends email on create' do
  mailer = double(:mailer)
  service = UserService.new(email_service: mailer)
  expect(mailer).to receive(:notify)
  service.create_and_notify(params)
end
```

### Clean Code Rules

- **Intention-Revealing Names**: `active_users_count` not `x` or `get_users`
- **Single Responsibility**: Each method one clear purpose
- **Guard Clauses First**: Return early for edge cases
- **Symbolize Constants**: `STATUS = :active` not `"active"`
- **Input â†’ Process â†’ Return**: Clear structure
- **Fail with Specific Errors**: Raise custom exceptions, not generic errors
- **Comments Explain Why**: "Why" not "what" (code shows what)

**Good**:

```ruby
def activate_user(user)
  return user if user.active? # Guard clause: early return

  user.update(activated_at: Time.current)
  send_welcome_email(user)
  user
rescue StandardError => e
  Rails.logger.error("Activation failed: #{e.message}")
  raise ActivationError, "Could not activate user #{user.id}"
end
```

### Project Structure

```bash
app/
â”œâ”€â”€ models/           # Business logic, validation, associations
â”œâ”€â”€ controllers/      # Request handling, coordination
â”œâ”€â”€ views/            # Templates (ERB, HAML)
â”œâ”€â”€ services/         # Business operations (multi-step workflows)
â”œâ”€â”€ workers/          # Background jobs (Sidekiq, etc.)
â”œâ”€â”€ decorators/       # View helpers, formatting
â”œâ”€â”€ mailers/          # Email composition
â””â”€â”€ jobs/             # Active Job classes

config/
â”œâ”€â”€ routes.rb         # Route definitions
â”œâ”€â”€ database.yml      # DB configuration
â””â”€â”€ environments/     # Environment-specific settings

db/
â”œâ”€â”€ migrate/          # Schema migrations
â””â”€â”€ seeds.rb          # Seed data

spec/  (or test/)
â”œâ”€â”€ models/           # Model tests
â”œâ”€â”€ controllers/      # Controller tests
â”œâ”€â”€ services/         # Service tests
â””â”€â”€ fixtures/         # Test data

lib/
â”œâ”€â”€ tasks/            # Rake tasks
â””â”€â”€ custom_modules/   # Custom code not in app/
```

---

## 3. Session Startup & Context

### Load Priority (Based on Task Complexity)

**Every Session (Mandatory)**:

1. Output compliance statement (Section 1)
2. Load README.md and AGENTS.md
3. Load relevant documentation (see below)
4. Identify environment: development/test/staging/production

**Quick Bug Fix** (30 min):

- [ ] Load relevant model/service/controller
- [ ] Understand failing test (if applicable)
- [ ] Load affected config/routes

**Standard Feature Work** (2-4 hours):

- [ ] Load README.md (project overview)
- [ ] Load current schema from `db/schema.rb`
- [ ] Load relevant models, services, controllers
- [ ] Load existing tests (same area) as reference

**Architecture/Refactoring** (4+ hours):

- [ ] Load all of above
- [ ] Load architecture documentation
- [ ] Load decision logs (if exists)
- [ ] Review existing patterns in codebase

**Gem-Specific Work**:

- [ ] Load `gems.md` when working with Devise, Sidekiq, RSpec, ActiveStorage,
      etc.

### Session Question Protocol

Before starting work, clarify:

1. **Task**: What is the clear objective?
2. **Scope**: Which models/controllers/services affected?
3. **Success**: What does "done" look like? (Acceptance criteria)
4. **Constraints**: Any architectural requirements or limitations?
5. **Context**: What related work exists? (PRs, issues, patterns)

---

## 4. Memory Bank

### Recommended Documentation Files

For reference:

```bash
root/
â”œâ”€â”€ README.md                    # Project overview, setup, running tests
â”œâ”€â”€ AGENTS.md                    # This file
â”œâ”€â”€ gems.md                      # Gem patterns & best practices (load when needed)
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ architecture.md          # System design, components, integrations
â”‚   â”œâ”€â”€ database-schema.md       # Data model overview, key relationships
â”‚   â”œâ”€â”€ api-conventions.md       # API standards, response formats
â”‚   â”œâ”€â”€ testing-patterns.md      # How to write tests (fixtures, factories)
â”‚   â”œâ”€â”€ deployment.md            # How to deploy (CI/CD, env vars)
â”‚   â””â”€â”€ decisions.md             # Architectural decision records (ADRs)
â””â”€â”€ .env.example                 # Environment variables (no secrets!)
```

### Seaching - ast-grep vs ripgrep (quick guidance)

**Use `ast-grep` when structure matters.** It parses code and matches AST nodes,
so results ignore comments/strings, understand syntax, and can **safely
rewrite** code.

- Refactors/codemods: rename APIs, change import forms, rewrite call sites or
  variable kinds.
- Policy checks: enforce patterns across a repo (`scan` with rules + `test`).
- Editor/automation: LSP mode; `--json` output for tooling.

**Use `ripgrep` when text is enough.** Itâ€™s the fastest way to grep
literals/regex across files.

- Recon: find strings, TODOs, log lines, config values, or non-code assets.
- Pre-filter: narrow candidate files before a precise pass.

**Rule of thumb**

- Need correctness over speed, or youâ€™ll **apply changes** â†’ start with
  `ast-grep`.
- Need raw speed or youâ€™re just **hunting text** â†’ start with `rg`.
- Often combine: `rg` to shortlist files, then `ast-grep` to match/modify with
  precision.

**Snippets**

Find structured code (ignores comments/strings):

```bash
ast-grep run -l TypeScript -p 'import $X from "$P"'
```

Codemod (only real `var` declarations become `let`):

```bash
ast-grep run -l JavaScript -p 'var $A = $B' -r 'let $A = $B' -U
```

Quick textual hunt:

```bash
rg -n 'console\.log\(' -t js
```

Combine speed + precision:

```bash
rg -l -t ts 'useQuery\(' | xargs ast-grep run -l TypeScript -p 'useQuery($A)' -r 'useSuspenseQuery($A)' -U
```

**Mental model**

- Unit of match: `ast-grep` = node; `rg` = line.
- False positives: `ast-grep` low; `rg` depends on your regex.
- Rewrites: `ast-grep` first-class; `rg` requires ad-hoc sed/awk and risks
  collateral edits.

### Using bv as an AI sidecar

bv is a fast terminal UI for Beads projects (.beads/beads.jsonl). It renders
lists/details and precomputes dependency metrics (PageRank, critical path,
cycles, etc.) so you instantly see blockers and execution order. For agents,
itâ€™s a graph sidecar: instead of parsing JSONL or risking hallucinated
traversal, call the robot flags to get deterministic, dependency-aware outputs.

- bv --robot-help â€” shows all AI-facing commands.
- bv --robot-insights â€” JSON graph metrics (PageRank, betweenness, HITS,
  critical path, cycles) with top-N summaries for quick triage.
- bv --robot-plan â€” JSON execution plan: parallel tracks, items per track, and
  unblocks lists showing what each item frees up.
- bv --robot-priority â€” JSON priority recommendations with reasoning and
  confidence.
- bv --robot-recipes â€” list recipes (default, actionable, blocked, etc.); apply
  via bv --recipe <name> to pre-filter/sort before other flags.
- bv --robot-diff --diff-since <commit|date> â€” JSON diff of issue changes,
  new/closed items, and cycles introduced/resolved.

Use these commands instead of hand-rolling graph logic; bv already computes the
hard parts so agents can act safely and quickly.

### bv Performance Considerations for AI Agents

bv uses a two-phase startup for responsive performance:

- **Phase 1 (instant):** Degree, topo sort, basic stats - available immediately
- **Phase 2 (async):** PageRank, betweenness, HITS, cycles - computed in
  background

**For large graphs (>500 nodes):**

- Some expensive metrics (betweenness) may be skipped automatically
- Cycle detection limited to prevent exponential blowup
- Use `--robot-insights` and check for skipped metrics

**Timeout handling:**

- All expensive algorithms have 500ms timeouts
- Robot output includes timeout flags when metrics are incomplete
- Design agents to handle partial data gracefully

**Diagnostic commands:**

- `bv --profile-startup` â€” detailed timing breakdown
- `bv --profile-startup --profile-json` â€” machine-readable profile

**Best practices:**

- Use `--robot-plan` for immediate actionable items (fast, Phase 1 only)
- Use `--robot-insights` when you need full graph metrics (waits for Phase 2)
- Avoid `--force-full-analysis` unless absolutely needed (can be slow)

See [docs/performance.md](docs/performance.md) for detailed tuning guide.

---

## 5. State Machine

### States: PLAN â†’ BUILD â†’ DIFF â†’ QA â†’ APPROVAL â†’ APPLY â†’ DOCS

```
PLAN [user approves] â†’ BUILD â†’ DIFF â†’ QA [pass] â†’ APPROVAL [user approves] â†’ APPLY â†’ DOCS â†’ END
  â†‘                    â†‘_________â†“________â†“_____[fail/changes]__________________â†“
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[major changes needed]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### PLAN State

**In**: Task contract | **Out**: Implementation outline\
**Exit**: User approves (says "approved", "proceed", "looks good")

**Required Content**:

```markdown
## Plan: [Feature/Fix Name]

**Analysis**:

- Current: `app/models/user.rb` (User model with X attributes)
- Affected: `app/controllers/users_controller.rb`, `spec/models/user_spec.rb`
- Pattern: Extends existing `Validatable` concern (see
  `app/models/concerns/validatable.rb`)

**Reuse Strategy**:

- Extend `User` model with new validation
- Add scope to User for filtering
- Follow existing test pattern from `spec/models/post_spec.rb`

**Implementation Steps**:

1. Add validation to `User` model (line 42)
2. Add scope to filter users (line 58)
3. Write tests mirroring `spec/models/post_spec.rb`
4. Update controller filter logic

**Integration Points**:

- Users controller calls new scope: `User.active`
- No breaking API changes

**Tests**: Unit (validation, scope) | Integration (controller filter) | Manual
(verification)

**Estimated Work**: 1-2 hours
```

**Exit**: User approves or provides feedback

### BUILD State

**In**: Approved plan | **Out**: Code changes (NOT APPLIED YET)\
**Actions**:

1. Create feature branch: `git checkout -b feature/description`
2. Write tests (RED phase) before implementation
3. Implement code (GREEN phase)
4. Run tests: `bundle exec rails test`
5. Run linter: `bundle exec rubocop -a`
6. **Golden Rule:** Run `ubs <changed-files>` before every commit. Exit 0 =
   safe. Exit >0 = fix & re-run
7. Generate diff (do NOT commit/push yet)

**TDD Phases**:

```ruby
# PHASE 1: RED (Failing test)
# spec/models/user_spec.rb
describe User do
  describe 'validations' do
    it 'validates email format' do
      user = User.new(email: 'invalid')
      expect(user.valid?).to be false
      expect(user.errors[:email]).to include('must be valid')
    end
  end
end

# PHASE 2: GREEN (Implementation)
# app/models/user.rb
class User < ApplicationRecord
  validates :email, format: { with: URI::MailTo::EMAIL_REGEXP, message: 'must be valid' }
end

# Verify: bundle exec rails test (should now pass)
```

## UBS Quick Reference for AI Agents

UBS stands for "Ultimate Bug Scanner": **The AI Coding Agent's Secret Weapon:
Flagging Likely Bugs for Fixing Early On**

**Commands:**

```bash
ubs file.ts file2.ts                    # Specific files (< 1s) â€” USE THIS
ubs $(git diff --name-only --cached)    # Staged files â€” before commit
ubs --only=js,ts src/                   # Language filter (3-5x faster)
ubs --ci --fail-on-warning .            # CI mode â€” before PR
ubs --help                              # Full command reference
ubs sessions --entries 1                # Tail the latest install session log
ubs .                                   # Whole project (ignores things like .next, node_modules automatically)
```

**Output Format:**

```text
âš ï¸  Category (N errors)
    file.ts:42:5 â€“ Issue description
    ğŸ’¡ Suggested fix
Exit code: 1
```

Parse: `file:line:col` â†’ location | ğŸ’¡ â†’ how to fix | Exit 0/1 â†’ pass/fail

**Fix Workflow:**

1. Read finding â†’ category + fix suggestion.
2. Navigate `file:line:col` â†’ view context.
3. Verify real issue (not false positive).
4. Fix root cause (not symptom).
5. Re-run `ubs <file>` â†’ exit 0.

**Speed Critical:** Scope to changed files. `ubs src/file.ts` (< 1s) vs `ubs .`
(30s). Never full scan for small edits.

**Bug Severity:**

- **Critical** (always fix): null/undefined safety, injection vulnerabilities,
  race conditions, resource leaks.
- **Important** (production): type narrowing, error handling, performance
  landmines.
- **Contextual** (judgment): TODO/FIXME, excessive console logs.

**Anti-Patterns:**

- âŒ Ignore findings â†’ âœ… Investigate each.
- âŒ Full scan per edit â†’ âœ… Scope to changed files.
- âŒ Fix symptom only â†’ âœ… Fix root cause.

**Exit**: Tests pass (`bundle exec rails test` â†’ exit 0), code passes linter
(`bundle exec rubocop`), code passes bug-scan (`ubs <changed-files>`), diff
generated

### DIFF State

**In**: BUILD complete | **Out**: Proposed changes with rationale\
**Present**:

```markdown
## Proposed Changes

**Files**:
```

app/models/user.rb | 5 +++ spec/models/user_spec.rb | 20 +++++++++++ 2 files, 25
insertions(+)

```
**Diff**:
[git diff output]

**Rationale**:
- Added email validation to User model per task requirements
- Tests follow existing pattern in `spec/models/post_spec.rb`
- No breaking changes to API

**Tests Passing**: âœ… 145 tests | âœ… Linter clean
```

### QA State

**In**: DIFF presented | **Out**: Test & ubs results | **Exit**: Tests pass OR
user waiver\
**Execute**:

1. Run full test suite: `bundle exec rails test`
2. Run linter: `bundle exec rubocop`
3. Run
4. Report results:

```markdown
## QA Results

**Tests**: âœ… PASS | Total: 145 | Duration: 12.3s **Linter**: âœ… PASS | Errors:
0 | Warnings: 0 **Build**: âœ… SUCCESS | Rails schema valid

**Verdict**: âœ… Ready for APPROVAL
```

**Exit**: All checks pass OR user grants explicit waiver

### APPROVAL State (HUMAN GATE)

**In**: QA passed | **Out**: User decision\
**Present**:

```markdown
## Ready for Approval âœ…

Code changes complete and tested. Ready for merge.

**Summary**:

- Added email validation to User model
- 20 new tests, all passing
- No breaking changes

**Files Modified**:

- `app/models/user.rb` (+5 lines)
- `spec/models/user_spec.rb` (+20 lines)

**Checks**:

- âœ… Tests pass: 145/145
- âœ… Linter clean
- âœ… Security reviewed: no secrets, validated input
- âœ… Follow Rails conventions

**Next**: Merge to develop branch, deploy to staging

---

**Please review. Reply with**:

- "approved" | "looks good" â†’ Merge to develop
- "change X" â†’ Back to BUILD
- "revert" â†’ Discard all
```

**Exit**: User approves explicitly

### APPLY State

**In**: User approved | **Out**: Changes applied/merged\
**Actions**:

1. Verify all tests pass one final time
2. Merge feature branch to develop: `git merge --no-ff feature/description`
3. Verify merge successful
4. Report success

### DOCS State

**In**: APPLY succeeded | **Out**: Documentation updated\
**Create/Update** (only if applicable):

1. Update README.md if setup changed
2. Update docs/architecture.md if structure changed
3. Add decision to docs/decisions.md if architectural choice made
4. Document any new patterns used

---

## 6. Task Contract

### Task Contract Template

```markdown
## Task: [Clear objective]

### Context

- **Repository**: [app name/path]
- **Related Issues**: [issue links]
- **Affected Models**: [User, Post, Comment]
- **Affected Controllers**: [UsersController, PostsController]

### Acceptance Criteria

- [ ] Users can [action]
- [ ] Tests cover [scenarios]
- [ ] Error messages are [specific]
- [ ] Performance impact: [measurements if relevant]

### Success Metrics

- All tests passing
- Linter clean (`bundle exec rubocop`)
- ubs <changed-files> checked 
- Code review approved

### Architectural Constraints

- Must follow existing patterns from `app/models/concerns/`
- Cannot modify public API signatures
- Must include Active Record validations

### Instructions

1. Create outline for approval
2. After approval, build in feature branch
3. Do not document until code approved

### Definition of Done

- Code merged to develop
- Tests at 95%+ coverage for new code
- Documentation updated
- Ready for staging deployment
```

---

## 7. Quality & Testing

### Test-Driven Development (TDD) Mandatory

**Three-Phase Cycle**:

1. **Red**: Write test that fails
   ```ruby
   it 'sends welcome email when user created' do
     expect {
       User.create(email: 'test@example.com')
     }.to have_enqueued_job(UserMailer)
   end
   ```

2. **Green**: Implement minimal code to pass
   ```ruby
   class User < ApplicationRecord
     after_create :send_welcome_email
     
     private
     
     def send_welcome_email
       UserMailer.welcome(self).deliver_later
     end
   end
   ```

3. **Refactor**: Improve without changing behavior
   ```ruby
   class User < ApplicationRecord
     has_one :welcome_email_sent, dependent: :destroy
     after_create :queue_welcome_email
     
     private
     
     def queue_welcome_email
       WelcomeEmailJob.perform_later(id)
     end
   end
   ```

### Completion Checklist

Before marking task complete, verify:

```bash
# Run all tests
bundle exec rails test
# Expected: exit code 0

# Run linter with auto-fix
bundle exec rubocop -a
# Expected: exit code 0 or only warnings

# Check for security issues
bundle audit
# Expected: no vulnerabilities

ubs <changed-files>
# Expected: 0 'Critcal' or 'Important'
```

---

## 8. Security & Code Review

### Security Checklist

**Before APPROVAL, verify**:

- [ ] No hardcoded secrets (API keys, passwords, tokens)
- [ ] All user input validated: `validates :email, presence: true`
- [ ] All user input encoded when displayed (Rails does this by default)
- [ ] No SQL injection: Use parameterized queries
      (`where(email: params[:email])`)
- [ ] Authentication required on sensitive endpoints
- [ ] Authorization verified (current_user can perform action?)
- [ ] Sensitive data logged appropriately (no passwords in logs)
- [ ] CSRF protection enabled (Rails default)
- [ ] Rate limiting on public endpoints (if applicable)

**Good**:

```ruby
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  before_action :authenticate_user!, except: [:index, :show]
  before_action :authorize_user!, only: [:edit, :update, :destroy]
  
  def update
    @user = User.find(params[:id])
    if @user.update(user_params)
      redirect_to @user
    else
      render :edit
    end
  end
  
  private
  
  def user_params
    params.require(:user).permit(:name, :email)
  end
  
  def authorize_user!
    unless current_user == @user || current_user.admin?
      redirect_to root_path, alert: 'Not authorized'
    end
  end
end
```

**Anti-Pattern**:

```ruby
# DON'T DO THIS
def update
  sql = "UPDATE users SET email = '#{params[:email]}' WHERE id = #{params[:id]}"
  ActiveRecord::Base.connection.execute(sql)
end
```

### Code Review Gates

**Must be reviewed and pass before merge**:

1. âœ… Tests passing
2. âœ… Linter clean
3. âœ… ubs bug-scan passed
4. âœ… Security checklist passed
5. âœ… No hardcoded secrets
6. âœ… Follows Rails conventions
7. âœ… Comments explain "why", not "what"

---

## 9. Troubleshooting

### Common Issues

| Problem               | Symptom                                   | Solution                                                                                 |
| --------------------- | ----------------------------------------- | ---------------------------------------------------------------------------------------- |
| **Test Failures**     | `bundle exec rails test` returns non-zero | Read error message, check test expectations, verify test data setup (fixtures/factories) |
| **Linter Errors**     | `bundle exec rubocop` fails               | Run `bundle exec rubocop -a` to auto-fix, resolve remaining manually                     |
| **Schema Mismatch**   | "relation does not exist" error           | Run `bundle exec rails db:migrate` to sync schema                                        |
| **Dependency Issues** | "Gem not found" error                     | Run `bundle install`, verify `Gemfile.lock` committed                                    |
| **Performance**       | Endpoint slow                             | Use `rails panel` (Rack::MiniProfiler) to profile, check N+1 queries                     |
| **State Issues**      | Tests pass individually, fail together    | Check test isolation, use `before_each` hooks, avoid shared state                        |

### Agent Stuck Protocol

**Condition**: Same error three consecutive attempts

**Response**:

1. Diagnose: Root cause of error, not symptom
2. Load more context: Relevant models, services, existing patterns
3. Propose alternative: Different technical approach
4. Request help: Ask user for clarification or direction

### Quick Reference Commands

```bash
# Setup
bundle install
bundle exec rails db:create db:migrate

# Running
rails s                              # Start server on localhost:3000
bundle exec rails console            # Interactive Rails shell

# Testing
bundle exec rails test               # All tests
bundle exec rails test test/file.rb  # Single test file
bundle exec rails test:system        # Browser tests only

# Linting/Quality
bundle exec rubocop                  # Check for style issues
bundle exec rubocop -a               # Auto-fix style issues
bundle audit                         # Check for security vulnerabilities

# Database
bundle exec rails db:migrate         # Apply pending migrations
bundle exec rails db:rollback        # Undo last migration
bundle exec rails db:seed            # Load seed data

# Code Generation
rails generate model User             # Generate User model scaffold
rails generate migration  # Generate migration
rails generate controller  # Generate controller
```

---

## Best Practices Summary

âœ… **DO**:

- Follow Rails conventions (CoC, MVC, REST)
- Write tests before code (TDD)
- Inject dependencies for testability
- Keep controllers skinny, models fat
- Use Active Record not raw SQL
- Validate input, encode output
- Comment "why", not "what"
- Cite code in plans: `app/models/user.rb:42`
- Request approval before merge
- Document architectural decisions
- Load `gems.md` when working with gems

âŒ **DON'T**:

- Hardcode secrets, APIs, or config
- Skip tests or commit untested code
- Modify code without reading full context
- Use mock data in production
- Write SQL instead of Active Record
- Put business logic in controllers
- Introduce unjustified abstraction
- Commit to main/master directly
- Force-push to shared branches
- Ignore security checklist

---

**Each session starts fresh. Be precise, be decisive, be correct.**\
**Mission**: Build Rails applications respecting conventions, following
established patterns, improving incrementally.
